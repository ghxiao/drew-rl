options{  JDK_VERSION = "1.5";  STATIC = false;  JAVA_UNICODE_ESCAPE = true;}PARSER_BEGIN(ProgramParser)package at.ac.tuwien.kr.dlprogram.parser;import at.ac.tuwien.kr.dlprogram.*;import java.sql.Types;public class ProgramParser{  public void process() throws ParseException  {  }}PARSER_END(ProgramParser)SKIP :{  " "|   "\t"|   "\n"|   "\r"|   < "%" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >}TOKEN :{  < NAF : "not" >|   < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9" ])* >|   < CONJUNCTION : "," >|   < IMPLY : ":-" >|   < ENDOFSTATEMENT : "." >|   < COMPARISON :    ">"  | ">="  | "="  | "<="  | "<"  | "!=" >|   < INTEGER :    "0"  | ([ "+", "-" ])? [ "1"-"9" ] ([ "0"-"9" ])* >|   < DOUBLE :    (      [ "1"-"9" ] ([ "0"-"9" ])*    | "0"    )    "." ([ "0"-"9" ])* [ "1"-"9" ] >|   < STRING :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |       ("\\" [ "n", "t", "b", "r", "f", "\\", "'", "\"" ])    )*    "\""     >|   < VARIABLE :    "_"  | [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9" ])* >|   < PLUS : "+" >|   < MINUS : "-" >|   < TIMES : "*" >|   < DIVIDE : "/" >|   < LEFTBRACKET : "(" >|   < RIGHTBRACKET : ")" >}Constant constant() :{  String name;  int type;}{  (    < INTEGER >    {      name = token.image;      type = Types.INTEGER;      return CacheManager.getInstance().getConstant(name, type);    }  |     < STRING >    {      name = token.image.substring(1, token.image.length() - 1);      type = Types.VARCHAR;      return CacheManager.getInstance().getConstant(name, type);    }  |     < IDENTIFIER >    {      name = token.image;      type = Types.VARCHAR;      return CacheManager.getInstance().getConstant(name, type);    }  )  {  }}Term variable() :{}{  < VARIABLE >  {    return CacheManager.getInstance().getVariable(token.image);  }}Functor functor() :{  Functor functor = new Functor();}{  < IDENTIFIER >  {    functor.setName(token.image);    return functor;  }}Function function() :{  Function function = new Function();  Functor functor;  Term term;}{  functor = functor()  {    function.setFunctor(functor);  }  < LEFTBRACKET >  [    term = term()    {      function.getTerms().add(term);    }    (      ","       term = term()      {        function.getTerms().add(term);      }    )*  ]  < RIGHTBRACKET >  {    return function;  }}Term unary() :{  Term term;}{  (    LOOKAHEAD(function())    term = function()  |     term = constant()  |     term = variable()  | < LEFTBRACKET > term = additive() < RIGHTBRACKET >  )  {    return term;  }}Term multiplicative() :{  Term left, right;  Token token;}{  left = unary()  {  }  (    (      token = < TIMES >    | token = < DIVIDE >    )    right = unary()    {      Function function = new Function();      Functor functor = new Functor();      functor.setName(token.image);      function.setFunctor(functor);      function.getTerms().add(left);      function.getTerms().add(right);      left = function;    }  )*  {    return left;  }}Term additive() :{  Term left, right;  Token token;}{  left = multiplicative()  {  }  (    (      token = < PLUS >    |       token = < MINUS >    )    right = multiplicative()    {      Function function = new Function();      Functor functor = new Functor();      functor.setName(token.image);      function.setFunctor(functor);      function.getTerms().add(left);      function.getTerms().add(right);      left = function;    }  )*  {    return left;  }}Term term() :{  Term term;}{  term = additive()  {    return term;  }}//Predicate predicate() ://{//	Predicate predicate = new Predicate();//}//{//	<IDENTIFIER>//	{//		predicate.setName(token.image);//		return predicate;//	}//}
Literal literal() :{  Literal literal = new Literal();  Predicate predicate;  String name;  Term term;  int arity = 0;}{  LOOKAHEAD(term() < COMPARISON >)  term = term()  {    literal.getTerms().add(term);  }  < COMPARISON >  {    predicate = CacheManager.getInstance().getPredicate(token.image, 2);    literal.setPredicate(predicate);  }  term = term()  {    literal.getTerms().add(term);  }  {    return literal;  }|   < IDENTIFIER >  {    name = token.image;  }  [    "("     term = term()    {      literal.getTerms().add(term);      arity++;    }    (      ","       term = term()      {        literal.getTerms().add(term);        arity++;      }    )*    ")"  ]  {    predicate = CacheManager.getInstance().getPredicate(name, arity);    literal.setPredicate(predicate);    return literal;  }}Clause clause() :{  Clause clause = new Clause();  Literal literal;  boolean not = false;}{  [    literal = literal()    {      clause.setHead(literal);    }  ]  [    < IMPLY >    {      // initialize the not state
      not = false;    }    [      < NAF >      {        not = true;      }    ]    literal = literal()    {      if (not)      {        clause.getNegativeBody().add(literal);      }      else      {        clause.getPositiveBody().add(literal);      }    }    (      < CONJUNCTION >      {        // initialize the not state
        not = false;      }      [        < NAF >        {          not = true;        }      ]      literal = literal()      {        if (not)        {          clause.getNegativeBody().add(literal);        }        else        {          clause.getPositiveBody().add(literal);        }      }    )*  ]  < ENDOFSTATEMENT >  {    if (clause.getBody().size() == 0)    {      clause.getPositiveBody().add(Literal.TRUE);    }    return clause;  }}Program program() :{  Program program = new Program();  Clause clause;}{  (    clause = clause()    {      if (clause.getHead().equals(Literal.FALSE) && (clause.getPositiveBody().contains(Literal.TRUE)))      {      // skip empty clause
      }      else      {        program.getClauses().add(clause);      }    }  )*  < EOF >  {    return program;  }}